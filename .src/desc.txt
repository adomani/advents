Finding the first and last digit (or the English name of a digit) in each row of the input.
### Description

#### Part 1

I simply scanned the characters in each line,
stopping at the first digit.

Next, I recycled the function, scanning the reversed list of characters.

#### Part 2

Very similar to part 1:
scan the characters as before, but also try
to match English spelling of digits,
before moving on to the next character.

I also recycled the previous function for the reverse scanning.
--
RGB-coloured cubes in a bag, finding sups and products.
### Comments

I wrote up two solutions for this problem.

One, more traditional, extracting the numbers from the input
and then performing the various operations on the extracted numbers.

The other, exploits defining new syntax for a Lean command.
This allows to make the input file itself a Lean command whose
evaluation is the solution to the problem that has it as its input.

The conversion is a little clunky, but this is just due to my limited
experience with parsing `Lean.Syntax`.
--
Operations and numbers scattered on a rectangular grid: compute a value from the natural numbers adjacent to certain symbols.
### Description

This mostly consisted of extracting positions of digits,
symbols and chaining consecutive digits to get numbers.

The biggest speed-up that I obtained was by extracting the
two rows surrounding a symbol, before looking for digit
neighbours of a given symbol!
--
A game with cards: computing the number of matches between two lists of natural numbers, some recursion.
### Description

#### Part 1

This was a relative straightforward parsing of the given numbers.
After that, what was left was finding common elements and
evaluating powers and sums.

#### Part 2

For the second part, I encoded the newly-generated cards in a
list of numbers.
Since the loop was over the initial length, I did not have to
take care that the list finished at the right place:
all excess entries would not be reached by the algorithm.
--
Seeds growing into locations as a series of permutations.
### Description

#### Part 1

The given data encodes a permutation of some range of natural
numbers.
To answer the first question, all that was needed was to pass
the initial 'seed' through the permutation and compute minima.

#### Part 2

It turns out that now the 'seed' represents a *very long*
list of seeds and they all have to go through the permutation
before the minimum is computed.

The trick that I used to compute the minimum is that the
permutations are *piece-wise increasing*.
Thus, the minimum is achieved on the lower end of an
increasing range, or at a place where there is a break.
Reverse-engineering where the breaks are and selecting the
ones contained in the 'seed ranges' turned out to be
sufficient to solve the question.
--
Toy boat race, with times and record distances.
### Description

Both questions revolved around computing the number
of integers on which a second-degree polynomial is
positive.
While the length of the real interval is simply the
square root of the discriminant of the quadratic,
the exact number of integer points inside is depends
on the exact location of the interval.
It turned out that I could only solve part 1 by a
brute-force enumeration, while for part 2 the
discriminant approach worked well.

The issue with part 1 was particularly frustrating,
since the correct answer is at most 1 away from the
discriminant, but fixing the 'off-by-one' error
involved too much fiddling around!
--
Camel cards, a simplified version of poker.
--
Traveling through the desert with ghosts.
--
Oasis measurements: compute iterated differences of sequences of integers.
--
Paths along pipes.
### Description

#### Part 1

Pretty straightforward:
* locate where `S` is on the map;
* look for which neighbours of `S` you can reach `S`;
* start from one of the neighbours and loop around
  following the rules and storing the visited positions.

Thus, you end up with a path starting from `S` and ending
just before it reaches `S` again.

Half the length of this path is the answer to part 1.

#### Part 2

I found this part very cute!

I oriented the path found in part 1, by attaching to each
position the counter-clockwise rotated step that you can take
from there (and to there, in case they yield different answers).

Now, from any location not on the path, start moving right.
* If you reach the path, look at whether the arrow is pointing
  towards you or away: in one case you are in, in the other out!
* If you reach the boundary of the grid, then you are out.
--
Distances between galaxies in an expanding universe.

### Description

#### Part 1

Extracted the coordinates of the positions of the galaxies.
Increased the `x` and `y` coordinates according to how
many skipped values there were before each one of them,
to reproduce the *expansion*.
After that, simply looped through all pairs,
accumulated the distances and divided by two.

#### Part 2

Same setup as for part 1, except that I increased the introduced
spacing in the *expansion* step.
--
