Finding the first and last digit (or the English name of a digit) in each row of the input.

### Description

#### Part 1

I simply scanned the characters in each line,
stopping at the first digit.

Next, I recycled the function, scanning the reversed list of characters.

#### Part 2

Very similar to part 1:
scan the characters as before, but also try
to match English spelling of digits,
before moving on to the next character.

I also recycled the previous function for the reverse scanning.
--
RGB-coloured cubes in a bag, finding sups and products.

### Comments

I wrote up two solutions for this problem.

One, more traditional, extracting the numbers from the input
and then performing the various operations on the extracted numbers.

The other, exploits defining new syntax for a Lean command.
This allows to make the input file itself a Lean command whose
evaluation is the solution to the problem that has it as its input.

The conversion is a little clunky, but this is just due to my limited
experience with parsing `Lean.Syntax`.
--
Operations and numbers scattered on a rectangular grid: compute a value from the natural numbers adjacent to certain symbols.

### Description

This mostly consisted of extracting positions of digits,
symbols and chaining consecutive digits to get numbers.

The biggest speed-up that I obtained was by extracting the
two rows surrounding a symbol, before looking for digit
neighbours of a given symbol!
--
A game with cards: computing the number of matches between two lists of natural numbers, some recursion.

### Description

#### Part 1

This is a relative straightforward parsing of the given numbers.
After that, what is left is finding common elements and
evaluating powers and sums.

#### Part 2

For the second part, I encoded the newly-generated cards in a
list of numbers.
Since the loop is over the initial length, I did not have to
take care that the list finished at the right place:
the algorithm does not reach any of the excess entries.
--
Seeds growing into locations as a series of permutations.

### Description

#### Part 1

The given data encodes a permutation of some range of natural
numbers.
To answer the first question, all that is needed is to pass
the initial 'seed' through the permutation and compute minima.

#### Part 2

It turns out that now the 'seed' represents a *very long*
list of seeds and they all need to go through the permutation
before the minimum is computed.

The trick that I used to compute the minimum is that the
permutations are *piece-wise increasing*.
Thus, the minimum is achieved on the lower end of an
increasing range, or at a place where there is a break.
Reverse-engineering where the breaks are and selecting the
ones contained in the 'seed ranges' turns out to be
sufficient to solve the question.
--
Toy boat race, with times and record distances.

### Description

Both questions revolve around computing the number
of integers on which a second-degree polynomial is
positive.
While the length of the real interval where
the polynomial is positive is simply the
square root of the discriminant of the quadratic,
the number of integer points inside it depends
on the exact location of the interval.
I could only solve part 1 by brute-force enumeration,
while for part 2 the discriminant approach worked well.

The issue with part 1 is particularly frustrating,
since the correct answer is at most 1 away from the
calculation involving the discriminant, but fixing
the 'off-by-one' error involved too much fiddling
around for my taste!
--
Camel cards, a simplified version of poker.

### Description

Both parts involve sorting 5-card hands of cards
following an order naturally described as
* first a lexicographic ordering of the
  frequency of each card in each hand;
* second a lexicographic ordering of the
  cards, in the dealt order.

By abstracting the sorting rules out of the main
functions, a good part of the code can be used
for both parts.

#### Part 1

Using rules very similar to poker, the first part
involves sorting a list of 5-card hands and doing
operations with the sorted rank of each hand (plus
also using a number given next to each hand
in the given input).

#### Part 2

The second part, changes the sorting function.
In the first sorting (the *frequency* phase), the card
labeled by `J` should be interpreted as the most
beneficial that it could be.
Given the rules for sorting, the revised `Joker` 
card is always best assigned to the most-frequent
value.
The second, tie-breaking sorting is lexicographic
as before, except that the relative order of the
card `J` with all the others is different.
--
Traveling through the desert with ghosts.

### Description

#### Part 1

In part 1, simply 'going through the moves' is fast enough.

#### Part 2

For the second part, the various starting points are
really independent processes each running with its own
period.
They all finish in their end-positions simultaneously
at time intervals that are proportional to the `lcm` of
the individual periods.
Thus, the answer is the least common multiple of the periods.

*Note*.
The periods for my input are all themselves multiples of 269.
--
Oasis measurements: compute iterated differences of sequences of integers.

### Description

For the two parts, the goal is to compute iterated first
differences of lists of numbers until all differences
are zero.
After that, you should extend either on the right or on
the left the initial sequence so that the final pattern 
of zeros persisted.

Equivalently, you could compute the polynomial of smallest
degree, whose values on `{1, 2, ..., n}` are the initial
sequence.
The two extensions are then simply the evaluation of the
polynomial at `n + 1` and at `0`.
--
Paths along pipes.

### Description

#### Part 1

Pretty straightforward:
* locate where `S` is on the map;
* look for which neighbours of `S` you can reach `S`;
* start from one of the neighbours and loop around
  following the rules and storing the visited positions.

Thus, you end up with a path starting from `S` and ending
just before it reaches `S` again.

Half the length of this path is the answer to part 1.

#### Part 2

I found this part very cute!

I oriented the path found in part 1, by attaching to each
position the counter-clockwise rotated step that you can take
from there (and to there, in case they yield different answers).

Now, from any location not on the path, start moving right.
* If you reach the path, look at whether the arrow is pointing
  towards you or away: in one case you are in, in the other out!
* If you reach the boundary of the grid, then you are out.
--
Distances between galaxies in an expanding universe.

### Description

#### Part 1

Extracted the coordinates of the positions of the galaxies.
Increased the `x` and `y` coordinates according to how
many skipped values there were before each one of them,
to reproduce the *expansion*.
After that, simply looped through all pairs,
accumulated the distances and divided by two.

#### Part 2

Same setup as for part 1, except that I increased the introduced
spacing in the *expansion* step.
--
Counting ways of filling in `#`s and `.`s

### Description

I solved part 1, but part 2 is still in progress!
--
Finding axes of symmetry among rock and ash.

### Description

The input data consists of several maps with locations of ash and rocks.
The goals revolve around finding horizontal or vertical axes of symmetry
in the maps.

#### Part 1

Each map has exactly one axis of symmetry.
From the positions of the axes, you can compute the answer.

#### Part 2

It turns out that, by changing exactly one map point
from ash to rock or viceversa, that the resulting map
acquires an axis of symmetry *different* from the
original one.
Of course, after the switch, the old axis of symmetry
may no longer be an axis of symmetry.
All that matters is that, after the switch, there are
at most two axes of symmetry:
* the new one that must be present,
* the old one, in case it stays.

In some maps, there may be several location switches that
comply with these rules, but they all happen to produce
the *same new* axis of symmetry.
Processing the locations of the new axes of symmetry as before
yields the answer to part 2.
--
